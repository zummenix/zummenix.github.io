<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#22272e name=theme-color><meta content="How to run swiftformat or swiftlint and other tools only on changed files leveraging awk" name=description><link href="https://zummenix.github.io/style.css?h=3da2cb78da548f69215b" rel=stylesheet><link href=https://zummenix.github.io/atom.xml rel=alternate title=Atom type=application/atom+xml><link href=/icons/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/icons/site.webmanifest rel=manifest><title>zummenix</title><body><header><nav><a href=/posts>All Posts</a><a href=/links>Links</a><a href=/>Home</a></nav></header><main><h1>SwiftFormat only changed files</h1><p><span class=tags-list> <svg viewbox="0 0 256 256" class=svg-icon fill=none stroke=currentColor xmlns=http://www.w3.org/2000/svg><path d=M122.7,25.9,42,42,25.9,122.7a8,8,0,0,0,2.2,7.2L132.5,234.3a7.9,7.9,0,0,0,11.3,0l90.5-90.5a7.9,7.9,0,0,0,0-11.3L129.9,28.1A8,8,0,0,0,122.7,25.9Z stroke-width=4% /><circle cx=84 cy=84 fill=currentColor r=12 /></svg>  <a href=/tags/swift>swift</a> · <a href=/tags/git>git</a> · <a href=/tags/awk>awk</a> · <a href=/tags/bash>bash</a> </span> <br> <span class=date> <svg viewbox="0 0 256 256" class=svg-icon xmlns=http://www.w3.org/2000/svg><g fill=none stroke=currentColor stroke-width=4%><rect height=190 width=220 x=18 y=40 /><line x1=72 x2=72 y1=18 y2=70 /><line x1=184 x2=184 y1=18 y2=70 /></g><g fill=currentColor stroke=none><circle cx=72 cy=110 r=12 /><circle cx=128 cy=110 r=12 /><circle cx=183 cy=110 r=12 /><circle cx=72 cy=170 r=12 /><circle cx=128 cy=170 r=12 /></g></svg>  January 7, 2023</span><p>There are a couple of reasons to run formatting or linting tools only on files that have been changed. In a big legacy project you probably don't want to format all files right away. Also you don't want spending extra seconds running these kinds of tools.<blockquote><p>I want to note that <a rel="noopener external" href=https://github.com/nicklockwood/SwiftFormat target=_blank>nicklockwood/SwiftFormat</a> uses caching by default, so the second point might be irrelevant.</blockquote><p>One solution is to use git to identify files that have been changed and run swiftformat on those. When I decided to implement this strategy I found a snippet of a bash script that does what I need. At least, I thought.<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>git</span><span style=color:#a3be8c> diff --diff-filter=d --name-only</span><span style=color:#81a1c1> |</span><span style=color:#88c0d0> grep</span><span style=color:#a3be8c> -e</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>\(.*\).swift$</span><span style=color:#eceff4>'</span><span style=color:#81a1c1> | while</span><span style=color:#88c0d0> read</span><span style=color:#a3be8c> line</span><span style=color:#81a1c1>; do</span></span>
<span class=giallo-l><span style=color:#88c0d0>    swiftformat</span><span style=color:#a3be8c>  --swiftversion</span><span style=color:#b48ead> 5.0</span><span style=color:#eceff4> "</span><span style=color:#81a1c1>${</span><span>line</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>done</span></span></code></pre><p>Let's see what is going on here. It uses <code>git diff</code> subcommand with argument <code>--diff-filter=d</code> and <code>--name-only</code> flag. <code>--diff-filter=d</code>, according to documentation, excludes paths for files that have been deleted, <code>--name-only</code> shows only file paths. The output of <code>git diff</code> is piped to <code>grep</code> with a regex to filter only <code>swift</code> files and then the result is piped to the <code>while</code> loop in which we run swiftformat for each file path.<p>This looks logical. You put this snippet in a file, make it executable and add it in a build phase in your Xcode project. It works in almost all cases. After working with this setup for a while I've noticed, for example, that this doesn't handle newly created files. It is a bummer and completely unexpected.<p>I didn't find any other solution, so I decided to look at <code>git status</code>. Seems like it knows and shows newly created, changed and renamed files. That is what we need. <code>git status</code> also has <code>--porcelain</code> flag which adds guaranties that format of the output doesn't change between git versions. Let's explore this solution further. If you run <code>git status --porcelain</code>, you'll see the output that looks something like this:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>A  file.swift</span></span>
<span class=giallo-l><span>?? another-file.swift</span></span></code></pre><p>Basically, it's a table with a status and a file path for each file. Our task is to filter the output of <code>git status --porcelain</code> by statuses and return file paths. This should be pretty easy to do in any programming language. I was thinking about using swift for this but decided to go against it. I don't want to impose a compilation step on the team. Another reason was that I wanted to try <code>awk</code> :). For those who don't know, <code>awk</code> is a text processing language and a tool. It is installed by default on every unix and linux. Since macos is a descendant of unix, we have it too. Nice!<p>Next step is to read the documentation about different statuses. <code>git status --help</code>. Ok, I think I understand the gist. Let's try it in practice and see what we are dealing with. The statuses that we are interested in are:<ul><li><code>M</code>- modified<li><code>A</code>- added<li><code>AM</code>- added and modified<li><code>??</code> - newly created untracted files<li><code>R</code> - renamed<li><code>RM</code> - renamed and modified</ul><p>Seems like the above list is complete for our use case.<p>It's time to try <code>awk</code> for real. You probably saw usage of <code>awk</code> in some scripts and maybe it looked like one-liner in a bash command. But here we have a lot to handle. So I decided to put all logic in a separate file and pass it to <code>awk</code> using <code>-f</code> argument. Now I'll show you the script that evolved during my late evening working on this:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=awk><span class=giallo-l><span>{</span></span>
<span class=giallo-l><span style=color:#81a1c1>  if</span><span> (</span><span style=color:#81a1c1>$1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>M</span><span style=color:#eceff4>"</span><span style=color:#81a1c1> || $1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>A</span><span style=color:#eceff4>"</span><span style=color:#81a1c1> || $1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>AM</span><span style=color:#eceff4>"</span><span style=color:#81a1c1> || $1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>??</span><span style=color:#eceff4>"</span><span>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> (</span><span style=color:#88c0d0>match</span><span>(</span><span style=color:#81a1c1>$0</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> /</span><span style=color:#eceff4>"</span><span style=color:#a3be8c>.*</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>/</span><span>)</span><span style=color:#81a1c1> !=</span><span style=color:#b48ead> 0</span><span>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>      print</span><span style=color:#88c0d0> substr</span><span>(</span><span style=color:#81a1c1>$0</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> RSTART+</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> RLENGTH-</span><span style=color:#b48ead>2</span><span>)</span></span>
<span class=giallo-l><span>    }</span><span style=color:#81a1c1> else</span><span> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>      print $2</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>  }</span><span style=color:#81a1c1> else if</span><span> (</span><span style=color:#81a1c1>$1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>R</span><span style=color:#eceff4>"</span><span style=color:#81a1c1> || $1 ==</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>RM</span><span style=color:#eceff4>"</span><span>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span> (</span><span style=color:#88c0d0>match</span><span>(</span><span style=color:#81a1c1>$0</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> /->/</span><span>)</span><span style=color:#81a1c1> !=</span><span style=color:#b48ead> 0</span><span>) {</span></span>
<span class=giallo-l><span>      path </span><span style=color:#81a1c1>=</span><span style=color:#88c0d0> substr</span><span>(</span><span style=color:#81a1c1>$0</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> RSTART+</span><span style=color:#b48ead>3</span><span>)</span></span>
<span class=giallo-l><span style=color:#81a1c1>      if</span><span> (</span><span style=color:#88c0d0>match</span><span>(path</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> /</span><span style=color:#eceff4>"</span><span style=color:#a3be8c>.*</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>/</span><span>)</span><span style=color:#81a1c1> !=</span><span style=color:#b48ead> 0</span><span>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        print</span><span style=color:#88c0d0> substr</span><span>(path</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> RSTART+</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> RLENGTH-</span><span style=color:#b48ead>2</span><span>)</span></span>
<span class=giallo-l><span>      }</span><span style=color:#81a1c1> else</span><span> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        print</span><span> path</span></span>
<span class=giallo-l><span>      }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>  }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>Let's pretend it's beautiful :)<p>No, it is not! But it handles all cases that we're interested in.<p>I'll explain the script a little bit. The <code>awk</code> treats each line in the input as a record. A record consists of fields. By default, fields are separated by a space. To access individual fields you can use variables <code>$1</code>, <code>$2</code> etc. The <code>$0</code> has the whole record. Here, in the top level <code>if else</code> block we are checking statuses. <code>R</code> and <code>RM</code> should be handled separately because they have different format for file paths incorporating <code>-></code> to show the renaming. We are interested in already renamed file, hence <code>match($0, /->/)</code> and taking what is to the right of <code>-></code>. This script also handles file names with spaces in them. We use the <code>match($0, /".*"/)</code> to find double quotes and taking the part that is inside them. Now I think you understand the script pretty well. I put it in a file and named it <code>git-changed-files.awk</code><p>Let's modify our formatting script:<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>git</span><span style=color:#a3be8c> status -uall --porcelain</span><span style=color:#81a1c1> |</span><span style=color:#88c0d0> awk</span><span style=color:#a3be8c> -f git-changed-files.awk</span><span style=color:#81a1c1> |</span><span style=color:#88c0d0> grep</span><span style=color:#a3be8c> -e</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>\(.*\).swift$</span><span style=color:#eceff4>'</span><span style=color:#81a1c1> | while</span><span style=color:#88c0d0> read</span><span style=color:#a3be8c> line</span><span style=color:#81a1c1>; do</span></span>
<span class=giallo-l><span style=color:#88c0d0>    swiftformat</span><span style=color:#a3be8c>  --swiftversion</span><span style=color:#b48ead> 5.0</span><span style=color:#eceff4> "</span><span style=color:#81a1c1>${</span><span>line</span><span style=color:#81a1c1>}</span><span style=color:#eceff4>"</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>done</span></span></code></pre><p>Note that I've included <code>-uall</code> argument in <code>git status</code> command to make it extra clear we are interested in untracted files too. Otherwise, if you create a new directory and a new swift file inside it, it will only show the path to the directory, not a file path.<p>You can take a look how I use it in my test project <a rel="noopener external" href=https://github.com/zummenix/GitHeart target=_blank>GitHeart</a> on github.<h2 id=conclusion>Conclusion</h2><p>In overall, this solution is simple and doesn't require any additional tools to install. Also the script might be useful to run other tools. I'm glad that I've tried <code>awk</code> and learned a little bit about it. The knowledge will be helpful next time I need to process text in nontrivial way.</main><footer><p>© 2026 Aleksey Kuznetsov. All rights reserved.<p>Content and media are licensed under the <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>. Code samples are under the <a href=/licenses/unlicense.txt>Unlicense</a>.</footer>