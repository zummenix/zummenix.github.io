<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#22272e name=theme-color><meta content="How to run swiftformat or swiftlint and other tools only on changed files leveraging awk" name=description><link href="https://zummenix.github.io/style.css?h=2b2e4964a1d2febd8013" rel=stylesheet><link href=https://zummenix.github.io/atom.xml rel=alternate title=Atom type=application/atom+xml><link href=/icons/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/icons/site.webmanifest rel=manifest><title>zummenix</title><body><main><ul class=navbar><li><a href=/>Home</a><li><a href=/posts>All Posts</a></ul><h1>SwiftFormat only changed files</h1><p><span class=tags-list> <svg viewbox="0 0 256 256" class=svg-icon fill=none stroke=currentColor xmlns=http://www.w3.org/2000/svg><path d=M122.7,25.9,42,42,25.9,122.7a8,8,0,0,0,2.2,7.2L132.5,234.3a7.9,7.9,0,0,0,11.3,0l90.5-90.5a7.9,7.9,0,0,0,0-11.3L129.9,28.1A8,8,0,0,0,122.7,25.9Z stroke-width=4% /><circle cx=84 cy=84 fill=currentColor r=12 /></svg>  <a href=/tags/swift>swift</a> · <a href=/tags/git>git</a> · <a href=/tags/awk>awk</a> · <a href=/tags/bash>bash</a> </span> <br> <span class=date> <svg viewbox="0 0 256 256" class=svg-icon xmlns=http://www.w3.org/2000/svg><g fill=none stroke=currentColor stroke-width=4%><rect height=190 width=220 x=18 y=40 /><line x1=72 x2=72 y1=18 y2=70 /><line x1=184 x2=184 y1=18 y2=70 /></g><g fill=currentColor stroke=none><circle cx=72 cy=110 r=12 /><circle cx=128 cy=110 r=12 /><circle cx=183 cy=110 r=12 /><circle cx=72 cy=170 r=12 /><circle cx=128 cy=170 r=12 /></g></svg>  January 7</span><p>There are a couple of reasons to run formatting or linting tools only on files that have been changed. In a big legacy project you probably don't want to format all files right away. Also you don't want spending extra seconds running these kinds of tools.<blockquote><p>I want to note that <a href=https://github.com/nicklockwood/SwiftFormat>nicklockwood/SwiftFormat</a> uses caching by default, so the second point might be irrelevant.</blockquote><p>One solution is to use git to identify files that have been changed and run swiftformat on those. When I decided to implement this strategy I found a snippet of a bash script that does what I need. At least, I thought.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>git</span><span> diff</span><span style=color:#bf616a> --diff-filter</span><span>=d</span><span style=color:#bf616a> --name-only </span><span>| </span><span style=color:#bf616a>grep -e </span><span>'</span><span style=color:#a3be8c>\(.*\).swift$</span><span>' | </span><span style=color:#b48ead>while </span><span style=color:#96b5b4>read</span><span> line; </span><span style=color:#b48ead>do
</span><span>    </span><span style=color:#bf616a>swiftformat  --swiftversion</span><span> 5.0 "$</span><span style=color:#a3be8c>{</span><span style=color:#bf616a>line</span><span style=color:#a3be8c>}</span><span>";
</span><span style=color:#b48ead>done
</span></code></pre><p>Let's see what is going on here. It uses <code>git diff</code> subcommand with argument <code>--diff-filter=d</code> and <code>--name-only</code> flag. <code>--diff-filter=d</code>, according to documentation, excludes paths for files that have been deleted, <code>--name-only</code> shows only file paths. The output of <code>git diff</code> is piped to <code>grep</code> with a regex to filter only <code>swift</code> files and then the result is piped to the <code>while</code> loop in which we run swiftformat for each file path.<p>This looks logical. You put this snippet in a file, make it executable and add it in a build phase in your Xcode project. It works in almost all cases. After working with this setup for a while I've noticed, for example, that this doesn't handle newly created files. It is a bummer and completely unexpected.<p>I didn't find any other solution, so I decided to look at <code>git status</code>. Seems like it knows and shows newly created, changed and renamed files. That is what we need. <code>git status</code> also has <code>--porcelain</code> flag which adds guaranties that format of the output doesn't change between git versions. Let's explore this solution further. If you run <code>git status --porcelain</code>, you'll see the output that looks something like this:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>A  file.swift
</span><span>?? another-file.swift
</span></code></pre><p>Basically, it's a table with a status and a file path for each file. Our task is to filter the output of <code>git status --porcelain</code> by statuses and return file paths. This should be pretty easy to do in any programming language. I was thinking about using swift for this but decided to go against it. I don't want to impose a compilation step on the team. Another reason was that I wanted to try <code>awk</code> :). For those who don't know, <code>awk</code> is a text processing language and a tool. It is installed by default on every unix and linux. Since macos is a descendant of unix, we have it too. Nice!<p>Next step is to read the documentation about different statuses. <code>git status --help</code>. Ok, I think I understand the gist. Let's try it in practice and see what we are dealing with. The statuses that we are interested in are:<ul><li><code>M</code>- modified<li><code>A</code>- added<li><code>AM</code>- added and modified<li><code>??</code> - newly created untracted files<li><code>R</code> - renamed<li><code>RM</code> - renamed and modified</ul><p>Seems like the above list is complete for our use case.<p>It's time to try <code>awk</code> for real. You probably saw usage of <code>awk</code> in some scripts and maybe it looked like one-liner in a bash command. But here we have a lot to handle. So I decided to put all logic in a separate file and pass it to <code>awk</code> using <code>-f</code> argument. Now I'll show you the script that evolved during my late evening working on this:<pre class=language-awk data-lang=awk style=color:#c0c5ce;background-color:#2b303b><code class=language-awk data-lang=awk><span>{
</span><span>  </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>M</span><span>" || </span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>A</span><span>" || </span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>AM</span><span>" || </span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>??</span><span>") {
</span><span>    </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#96b5b4>match</span><span>(</span><span style=color:#bf616a>$0</span><span>, </span><span style=color:#96b5b4>/"</span><span style=color:#b48ead>.</span><span>*</span><span style=color:#96b5b4>"/</span><span>) != </span><span style=color:#d08770>0</span><span>) {
</span><span>      </span><span style=color:#b48ead>print </span><span style=color:#96b5b4>substr</span><span>(</span><span style=color:#bf616a>$0</span><span>, </span><span style=color:#bf616a>RSTART</span><span>+</span><span style=color:#d08770>1</span><span>, </span><span style=color:#bf616a>RLENGTH</span><span>-</span><span style=color:#d08770>2</span><span>)
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>      </span><span style=color:#b48ead>print </span><span style=color:#bf616a>$2
</span><span>    }
</span><span>  } </span><span style=color:#bf616a>else </span><span style=color:#8fa1b3>if </span><span>(</span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>R</span><span>" || </span><span style=color:#bf616a>$1 </span><span>== "</span><span style=color:#a3be8c>RM</span><span>") {
</span><span>    </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#96b5b4>match</span><span>(</span><span style=color:#bf616a>$0</span><span>, </span><span style=color:#96b5b4>/->/</span><span>) != </span><span style=color:#d08770>0</span><span>) {
</span><span>      </span><span style=color:#bf616a>path </span><span>= </span><span style=color:#96b5b4>substr</span><span>(</span><span style=color:#bf616a>$0</span><span>, </span><span style=color:#bf616a>RSTART</span><span>+</span><span style=color:#d08770>3</span><span>)
</span><span>      </span><span style=color:#8fa1b3>if </span><span>(</span><span style=color:#96b5b4>match</span><span>(</span><span style=color:#bf616a>path</span><span>, </span><span style=color:#96b5b4>/"</span><span style=color:#b48ead>.</span><span>*</span><span style=color:#96b5b4>"/</span><span>) != </span><span style=color:#d08770>0</span><span>) {
</span><span>        </span><span style=color:#b48ead>print </span><span style=color:#96b5b4>substr</span><span>(</span><span style=color:#bf616a>path</span><span>, </span><span style=color:#bf616a>RSTART</span><span>+</span><span style=color:#d08770>1</span><span>, </span><span style=color:#bf616a>RLENGTH</span><span>-</span><span style=color:#d08770>2</span><span>)
</span><span>      } </span><span style=color:#b48ead>else </span><span>{
</span><span>        </span><span style=color:#b48ead>print </span><span style=color:#bf616a>path
</span><span>      }
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre><p>Let's pretend it's beautiful :)<p>No, it is not! But it handles all cases that we're interested in.<p>I'll explain the script a little bit. The <code>awk</code> treats each line in the input as a record. A record consists of fields. By default, fields are separated by a space. To access individual fields you can use variables <code>$1</code>, <code>$2</code> etc. The <code>$0</code> has the whole record. Here, in the top level <code>if else</code> block we are checking statuses. <code>R</code> and <code>RM</code> should be handled separately because they have different format for file paths incorporating <code>-></code> to show the renaming. We are interested in already renamed file, hence <code>match($0, /->/)</code> and taking what is to the right of <code>-></code>. This script also handles file names with spaces in them. We use the <code>match($0, /".*"/)</code> to find double quotes and taking the part that is inside them. Now I think you understand the script pretty well. I put it in a file and named it <code>git-changed-files.awk</code><p>Let's modify our formatting script:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>git</span><span> status</span><span style=color:#bf616a> -uall --porcelain </span><span>| </span><span style=color:#bf616a>awk -f</span><span> git-changed-files.awk | </span><span style=color:#bf616a>grep -e </span><span>'</span><span style=color:#a3be8c>\(.*\).swift$</span><span>' | </span><span style=color:#b48ead>while </span><span style=color:#96b5b4>read</span><span> line; </span><span style=color:#b48ead>do
</span><span>    </span><span style=color:#bf616a>swiftformat  --swiftversion</span><span> 5.0 "$</span><span style=color:#a3be8c>{</span><span style=color:#bf616a>line</span><span style=color:#a3be8c>}</span><span>";
</span><span style=color:#b48ead>done
</span></code></pre><p>Note that I've included <code>-uall</code> argument in <code>git status</code> command to make it extra clear we are interested in untracted files too. Otherwise, if you create a new directory and a new swift file inside it, it will only show the path to the directory, not a file path.<p>You can take a look how I use it in my test project <a href=https://github.com/zummenix/GitHeart>GitHeart</a> on github.<h2 id=conclusion>Conclusion</h2><p>In overall, this solution is simple and doesn't require any additional tools to install. Also the script might be useful to run other tools. I'm glad that I've tried <code>awk</code> and learned a little bit about it. The knowledge will be helpful next time I need to process text in nontrivial way.</main><footer><p>© 2025 Aleksey Kuznetsov. All rights reserved.<p>Content and media are licensed under the <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>. Code samples are under the <a href=/licenses/unlicense.txt>Unlicense</a>.</footer>